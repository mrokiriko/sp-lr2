; nasm -f elf arr.asm && gcc -m32 -o arr arr.o && ./arr

extern    printf  

SECTION .data

   arr: dd 1, 2, -3, 7, 5, -11, 7, 8, -9, 10  ; массив слов

   arr_len: dd 10                             ; длина массива

   sum_str: db "%d", 10, 0                    ; строка вывода

SECTION .text               ; секция кода

global main             ; стандартная точка входа для gcc

main:                   ; точка входа программы

   mov  ebx, 0          ; для хранения суммы


   push    ebp          ; подготовка стека
   mov     ebp, esp

   mov ecx, [arr_len]   ; счетчик для цикла .loop (Команды управления циклом используют регистр ECX в качестве счётчика цикла)
   mov esi, 0           ; счетчик для перебора чисел массива

.loop:

   mov eax, [arr + esi]       ; помещаем значение массива в регистр eax, где esi - отсуп в байтах

   test eax, eax              ; проверяем, является ли значение массива отрицательным    
   jnl  .positive             ; если значение больше 0, то пропускаем инвертирование знака
   neg eax                    ; инвертирование отрицательного числа

.positive:

   add  ebx, eax           ; увеличиваем сумму

   add esi, 4              ; увеличиваем счетчик (отступ) на 4 байта
   loop .loop              ; если счетчик (ecx) не равен нулю, запускаем новый цикл


   push ebx                                    ; кладем значение суммы в стек
   push dword sum_str                          ; кладем строку в стек для использования в printf
   call printf                                 ; вызов printf
   add esp, 8                                  ; добавляем 4 байтов * 2 в стек


   mov     esp, ebp    ; убрать стек
   pop     ebp         
   mov     eax,0       ; выход без ошибок
   ret                 
